---
layout: post
title: 位运算小结
category: 笔记
tags: C语言
keywords: 位运算,C语言
description: 
---

# 位运算

字节，在大多数计算机系统里，一个字节(a byte)包含8个叫做位(bits)的小单元。一个位只能有两个取值，0或者1。如位串`01100100`即表示`4 + 32 + 64 = 100`。

大多数计算机用所谓的二类补数(twos complement)表示负数。此时，最左边的一位为符号位，如果此位为1，则表示负数，为0则表示正数，余下的位用来表示具体的数值。使用二类补数的编码方案表示时，-1的所有位都是1，即`11111111`。

将一个十进制负数转化为二进制符号数时，首先给这个数加1，然后用其绝对值的二进制表示，最后对这个二进制数求补就可以了。所谓求补，即将所有的1变为0，而将所有的0变为1。如用二进制数表示-5，则`-5 + 1 = -4,` 4的二进制:`00000100`，求补之后:`11111011`，此即-5的二进制数。

一类补数(ones complement)通过将某个负数对应的正数的二进制串的每一位直接求反得到，这种方法的问题在于0在该编码方案中有两种表示方法。

将一个二进制负数转换为十进制的方法是:

**首先对其所有位求补，然后将结果转换为十进制，再改变其符号，最后再减1就可以了。**

使用二类补数表示数字时，用n位可以存数的最大正数是2的(n-1)次方再减1，如八位数则最大值为127。用n位可存储的最小负数是负2的(n-1)次方。

在大多数现代处理器上，整数一般占据计算机内存中4个连续的字节，也就是32位。

修饰符unsigned可以有效地增加变量的表达范围，即处理的仅仅是正数，最左一位不用作为符号位，作为扩展位将变量存储的值变为原来的两倍。即2的n次方减1。

---

## 位运算符

| 符号     | 操作    |
| --------| -----:  |
| &    	| 按位与   |
| \|  	| 按位或   |
| ^    	| 按位抑或 |
| ～		| 取反 |
| <<	| 左移 |
| >>	| 右移 |

上表列出的所有运算符，除过“取反”运算符~之外，都是二元运算符。对于浮点数，无法应用位操作。

---

## 按位与运算符( & )

当两个数据进行按位与运算时，我们就对它们的二进制位进行一位一位的比较。如果两个相应的二进制位都为1，则该位的结果为1；否则，结果为0。真值表：

    b1	b2	b1 & b2
    -----------------------------
    0	0	0
    0	1	0
    1	0	0
    1	1	1

定义w1和w2为(16位)短型整数，其值分别为25和77，则下面语句将w3赋值为9；

	w3 = w1 & w2;

上式的运算过程：

    w1 0000000000011001   25
    w2 0000000001001101 & 77
        --------------------
    w3 0000000000001001   9

**按位与运算经常用于屏蔽一个数中的某些指定位。**也就是说，我们可以用它方便地将一个数据的指定位保留，而将其他位清零。下面的语句:

	w3 = w1 & 3;

将w1和3按位与的结果赋值给w3.**这就相当于将w1里的除过最右边2位的所有位清零，只保留w1最右边的两位并将其赋予w3.**

二进制运算符可以和赋值运算结合起来，语句:

	word &= 15;

等价于:

	word word & 15;

作用为将word中除过右边四位的其他位清零。

常用八进制或十六进制在位运算中表示常量，例如在32位计算机上进行位运算时，因为32是4的倍数(一位十六进制所含的二进制位数刚好时4)，所以采用十六进制表示。

---

## 按位或运算符( | )

C语言里，当两个数据进行按位或运算时，我们仍对它们的二进制位逐位进行比较。两个相应的二进制位只要有一个为1，则该位的结果为1.真值表：

    b1	b2	b1 | b2
    ------------------------
    0	0	0
    0	1	1
    1	0	1
    1	1	1

按照上面的规则，如果w1和w2为无符号整数，其值分别为0431和0152，我们对w1和w2进行按位或运算，结果得到一个八进制数0573：

    w1   ... 100 011 001   0431
    w2   ... 001 101 010 | 0152
        ----------------------------
	     ... 101 111 011   0573

**按位或运算常用于将一个数据的某些位设定为1。**例如，语句：

	w1 = w1 & 07; // w1 &= 07;

将w1的最右边的3位都置为1，而不管操作前它们时何状态。

---

## 按位异或运算符( ^ )

按位异或运算符也被称作XOR操作符。C语言里，对两个数进行按位异或运算时，如果两个相应的二进制位有一个为1，但又不全部为1，则该位的结果为1.真值表：

    b1	b2	b1 ^ b2
    -----------------------
    0	0	0
    0	1	1
    1	0	1
    1	1	0

如果w1和w2为八进制整数，其值分别为0536和0266，我们对w1和w2进行按位异或运算，结果得到一个八进制数0750：

    w1   ... 101 011 110   0536
    w2   ... 010 110 110 ^ 0266
        ----------------------------
	     ... 111 101 000   0750

**异或运算符的一个有趣特性，即任何一个数与自己异或后值为0。**

**异或运算的另一个有趣的应用是，可以在不用额外存储单元的情况下高效第交换两个数值。**

不使用临时变量的情况下交换两个值：

	i1 ^= i2;
    i2 ^= i1;
    i1 ^= i2;

举例：

    i1   ... 101 011 110   0536
    i2   ... 010 110 110 ^ 0266
        ----------------------------
	i1   ... 111 101 000 ^ 0750
        ----------------------------
    i2   ... 101 011 110 ^ 0536
        ----------------------------
    i1   ... 010 110 110   0266

---

## 取反运算符( ～ )

取反运算符～是一个一元运算符，它的作用时简单第将它的操作数按位取反，即0变1,1变0.真值表：

	b1	b2
    --------
    0	 1
    1	 0

如果w1是一个16位的短整数，值为八进制0122457，对它取反得到一个八进制值0055320：

	w1  1 010 010 100 101 111   0122457
    ~w1 0 101 101 011 010 000   0055320

**当我们不知道正在处理的操作数的准确长度时，可以使用取反运算符**。将某个
整数w1的低位设置为0，不确定机器是用32位还是64位显示整数，则可以使用如下语句处理：

	w1 &= ～1;

对1取反后，除去低位为0外其余皆为1，w1与之进行与运算，除去低位，其他位数不变，低位变为0。

---

## 各种运算符的优先级

二进制位运算符与、或和异或比任何一个算数运算符和关系运算符的优先级都低，但却高于逻辑运算符(AND)和(OR)，其中，运算符按位"与"比"异或"优先级要高，而"异或"的优先级高于"或"。

一元运算符“取反”比任何二元运算符的优先级都高。

---

## 总结

- **&  与，如果两个相应二进制位都为1，则结果为1，否则为0；**
- **\| 或，两个二进制中只要有一个为1，则结果为1，否则为0；**
- **^ 异或，两个中有一个为1，但不全为1，则结果为1，否则为0；**
- **~ 取反，0变1,1变0。**
- **优先级：取反 -> 与 -> 异或 -> 或**

---

## 左移运算符( << )

我们对一个数据进行左移时，包含在其中的位逐一向左移动。与这一操作有关的是需要移动的空间(位数)。左移时高位的数据将会丢失，而相应地在低位补0.因此，如果w1为3，则表达式：

	w1 = w1 << 1; // 等价于 w1 <<= 1;

将3左移一位(相当于该数乘以2)，结果是将6赋值给w1：

	w1      ...  000 011 03
	w1 << 1 ...  000 110 06

---

## 右移运算符( >> )

对一个数据进行向右移位时，低位的数据将会丢失。如果进行移位的是无符号数，则相应的将0移进数据的左边(即左边补0)。换句话说就是将0移进高位。如果是一个符号数，符号位是0，即正数，跟前面一样；如果是1，即负数，有些机器是将1移进左边，其他的是将0移进左边，前面称为算术右移，后者为逻辑右移。

如果w1是一个用32位表示的无符号整数，值为16进制数F777EE22，则我们可以使用下面语句将w1右移一位：

	w1 >>= 1;

结果是将w1的值设置为7BBBF711.运算的算式如下：

	w1       1111 0111 0111 0111 1110 1110 0010 0010 F777EE22
	w1 >>= 1 0111 1011 1011 1011 1111 0111 0001 0001 7BBBF711

---

## 位域(Bit Fields)

为了处理包含几个信息的数据项，可以将信息打包存放到一个字节或一个字的其中几位。两种方法：一种是简单地使用一个int表示存储的数据，使用位运算符存取int中想要的位；另一种是使用位域定义一个打包信息的结构体。

第一种方法：将5个数据打包存放到一个字里面，在内存中维护一个很大的关于这些变量的表。假定这些数据中有3个是标记(true/false)，分别是f1、f2和f3；第四个是一个叫type的整数，取值范围是1到255；最后一个是叫做index的整数，取值范围是0到100,000.标记f1、f2和f3需要3位，type需要8位，index需要18位，总共需要29位。可以用如下语句定义一个整型变量，用它包含着5个数值：

	unsigned int packed_data;

可以通过位运算随意地将packed_data里面的位分配给这5个需要存储的数据。

	   000  0  0  0  00000000  000000000000000000
	unused  f1 f2 f3   type           index

一般地(type域为0时)，可以通过将数值n向右移动合适的位数并进行或运算，来设置packed_data的type位域为n：

	packed_data:
	packed_data |= 7 << 18;

为了保证保证n是一个0到255之间的数，在它被移位之前可以让它与0xff进行按位与运算。

保证将type域清0，可以通过让它与一个在type域的位全为0而在其他位全为1的值(常称为掩码)进行位与操作来完成：

	packed_data &= 0xfc03ffff;

为了避免必须计算出掩码的烦恼，也为了使得操作不依赖于整数的长度，我们可以用下面的语句将type域设置为0：

	packed_data &= ~(0xff << 18);

综上所述，可以将packed_data的type域设置为n的低8位所包含的值，而不管之前这个域里面保存的是什么：

	packed_data = (packed_data &= ~(0xff << 18)) | ((n & 0xff) << 18);

提取type域并将其赋值到变量n中：

	n = (packed_data >> 18) & 0xff;

定义域packed_data作用相同的位域：

	struct packed_struct{
		unsigned int :3; //占用3位
		unsigned int f1:1;
		unsigned int f2:1;
		unsigned int f3:1;
		unsigned int type:8;
		unsigned int index:18;
	};

**在存储单元中位域的空间分配方向是无法保证的，有可能由从左到右分配，也有可能从右到左分配。**

可以在一个包含位域的结构体里包括正常的数据类型:

	struct table_entry{
		int count;
		char c;
		unsigned int f1:1;
		unsigned int f2:1;
	};

我们只能将位域声明为整型数或者_Bool类型，声明是最好明确指定signed或者unsigned int。另外，我们不能使用位域的地址，即不存在一个“指向位域的指针”类型。

长度为0的的未命名域，它的作用是使下一个位域从下一个存储单元开始存放。









